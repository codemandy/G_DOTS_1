from typing import Iterable, List, Sequence, Tuple

import math


def _hex_color_to_svg(hx: str) -> str:
	return hx.lower()


def _nearest_neighbor_order(points: Sequence[Tuple[float, ...]]) -> List[int]:
	"""Order points by nearest neighbor. Works with 2-tuple (x,y) or 3-tuple (x,y,scale)."""
	if not points:
		return []
	remaining = list(range(len(points)))
	order: List[int] = []
	# Start at the left-most, top-most point for determinism
	start_idx = min(remaining, key=lambda i: (points[i][0], points[i][1]))
	current = start_idx
	order.append(current)
	remaining.remove(current)
	while remaining:
		cx, cy = points[current][0], points[current][1]
		best_i = None
		best_d2 = float("inf")
		for i in remaining:
			x, y = points[i][0], points[i][1]
			dx = x - cx
			dy = y - cy
			d2 = dx * dx + dy * dy
			if d2 < best_d2:
				best_d2 = d2
				best_i = i
		current = best_i  # type: ignore
		order.append(current)  # type: ignore
		remaining.remove(current)  # type: ignore
	return order


def write_svg_circles(
	*,
	layers: Iterable[Tuple[str, str, Sequence[Tuple[float, float, float]], float]],
	width_mm: float,
	height_mm: float,
	order: str,
	output_path: str,
	opacity_min: float = 0.15,
	opacity_max: float = 0.85,
) -> None:
	# Build SVG string with proper layer groups
	# Points can be (x, y, scale) tuples where scale modulates the radius
	parts: List[str] = []
	parts.append(
		f'<svg xmlns="http://www.w3.org/2000/svg" '
		f'xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" '
		f'width="{width_mm}mm" height="{height_mm}mm" viewBox="0 0 {width_mm} {height_mm}">\n'
	)
	parts.append('  <desc>Generated by G-DOTS: each color is in its own layer group</desc>\n')
	
	for layer_name, color_hex, points, base_radius in layers:
		if not points:
			continue
		# Create a separate group for each color layer
		parts.append(f'  <g id="{layer_name}" inkscape:groupmode="layer" inkscape:label="{layer_name}">\n')
		
		if order == "nearest":
			idxs = _nearest_neighbor_order(points)
			ordered = [points[i] for i in idxs]
		else:
			ordered = list(points)
		
		fill_color = _hex_color_to_svg(color_hex)
		for point in ordered:
			x, y, scale = point  # Unpack 3-tuple
			# Variable radius based on scale factor
			radius = base_radius * scale
			# Filled circles with opacity for watercolor blending
			# Scale represents density: higher scale = more opaque (darker areas)
			# Map scale (0.5-1.5) to opacity range (opacity_min to opacity_max)
			normalized_scale = (scale - 0.5) / 1.0  # 0.5->0, 1.5->1
			opacity = opacity_min + normalized_scale * (opacity_max - opacity_min)
			opacity = max(0.05, min(1.0, opacity))
			parts.append(
				f'    <circle cx="{x:.4f}" cy="{y:.4f}" r="{radius:.4f}" fill="{fill_color}" fill-opacity="{opacity:.3f}" stroke="none" />\n'
			)
		parts.append("  </g>\n")
	
	parts.append("</svg>\n")
	with open(output_path, "w", encoding="utf-8") as f:
		f.write("".join(parts))
