from typing import Iterable, List, Sequence, Tuple, Optional

import math


def _hex_color_to_svg(hx: str) -> str:
	return hx.lower()


def _hex_to_rgb(hx: str) -> Tuple[int, int, int]:
	h = hx.lstrip("#")
	if len(h) == 3:
		r = int(h[0] * 2, 16)
		g = int(h[1] * 2, 16)
		b = int(h[2] * 2, 16)
	else:
		r = int(h[0:2], 16)
		g = int(h[2:4], 16)
		b = int(h[4:6], 16)
	return (r, g, b)


def _nearest_neighbor_order(points: Sequence[Tuple[float, ...]]) -> List[int]:
	"""Order points by nearest neighbor. Works with 2-tuple (x,y) or 3-tuple (x,y,scale)."""
	if not points:
		return []
	remaining = list(range(len(points)))
	order: List[int] = []
	# Start at the left-most, top-most point for determinism
	start_idx = min(remaining, key=lambda i: (points[i][0], points[i][1]))
	current = start_idx
	order.append(current)
	remaining.remove(current)
	while remaining:
		cx, cy = points[current][0], points[current][1]
		best_i = None
		best_d2 = float("inf")
		for i in remaining:
			x, y = points[i][0], points[i][1]
			dx = x - cx
			dy = y - cy
			d2 = dx * dx + dy * dy
			if d2 < best_d2:
				best_d2 = d2
				best_i = i
		current = best_i  # type: ignore
		order.append(current)  # type: ignore
		remaining.remove(current)  # type: ignore
	return order


def write_svg_circles(
	*,
	layers: Iterable[Tuple[str, str, Sequence[Tuple[float, float, float]], float]],
	width_mm: float,
	height_mm: float,
	order: str,
	output_path: str,
	opacity_min: float = 0.15,
	opacity_max: float = 0.85,
 	fill_mode: str = "opacity",
	per_point_rgba: Optional[Sequence[Sequence[Tuple[int, int, int, float]]]] = None,
) -> None:
	# Build SVG string with proper layer groups
	# Points can be (x, y, scale) tuples where scale modulates the radius
	parts: List[str] = []
	parts.append(
		f'<svg xmlns="http://www.w3.org/2000/svg" '
		f'xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" '
		f'width="{width_mm}mm" height="{height_mm}mm" viewBox="0 0 {width_mm} {height_mm}">\n'
	)
	parts.append('  <desc>Generated by G-DOTS: each color is in its own layer group</desc>\n')
	
	layer_index = -1
	for layer_name, color_hex, points, base_radius in layers:
		layer_index += 1
		if not points:
			continue
		# Create a separate group for each color layer
		parts.append(f'  <g id="{layer_name}" inkscape:groupmode="layer" inkscape:label="{layer_name}">\n')
		
		if order == "nearest":
			idxs = _nearest_neighbor_order(points)
			ordered = [points[i] for i in idxs]
		else:
			ordered = list(points)
		
		fill_color = _hex_color_to_svg(color_hex)
		rgb_color = _hex_to_rgb(fill_color)
		for j, point in enumerate(ordered):
			x, y, scale = point  # Unpack 3-tuple
			# Variable radius based on scale factor
			radius = base_radius * scale
			# Filled circles with opacity for watercolor blending
			# Scale represents density: higher scale = more opaque (darker areas)
			# Map scale (0.5-1.5) to opacity range (opacity_min to opacity_max)
			normalized_scale = (scale - 0.5) / 1.0  # 0.5->0, 1.5->1
			opacity = opacity_min + normalized_scale * (opacity_max - opacity_min)
			opacity = max(0.05, min(1.0, opacity))
			if fill_mode == "rgba":
				# Use rgb(...) with fill-opacity; rgba() is not reliably supported in SVG fill
				if per_point_rgba is not None:
					pr, pg, pb, pa = per_point_rgba[layer_index][j]
					parts.append(
						f'    <circle cx="{x:.4f}" cy="{y:.4f}" r="{radius:.4f}" fill="rgb({pr},{pg},{pb})" fill-opacity="{pa:.3f}" stroke="none" />\n'
					)
					continue
				fr, fg, fb = rgb_color
				parts.append(
					f'    <circle cx="{x:.4f}" cy="{y:.4f}" r="{radius:.4f}" fill="rgb({fr},{fg},{fb})" fill-opacity="{opacity:.3f}" stroke="none" />\n'
				)
			else:
				parts.append(
					f'    <circle cx="{x:.4f}" cy="{y:.4f}" r="{radius:.4f}" fill="{fill_color}" fill-opacity="{opacity:.3f}" stroke="none" />\n'
				)
		parts.append("  </g>\n")
	
	parts.append("</svg>\n")
	with open(output_path, "w", encoding="utf-8") as f:
		f.write("".join(parts))
